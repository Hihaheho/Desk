use bevy::prelude::*;

use desk_plugin::DeskSystem;
use desk_window::{
    ctx::Ctx,
    widget::{Widget, WidgetId},
    window::{DefaultWindow, Window},
};
use deskc_ast::{expr::Expr, meta::WithMeta};
use deskc_ids::NodeId;
use deskc_macros::ast;
use deskc_type::{DsonTypeDeduction, Effect};
use dworkspace::{
    conversions::ast_type_to_type,
    prelude::{AttributePatch, Content, Event, OperandPatch},
    Workspace,
};

use once_cell::sync::Lazy;

pub struct PlaygroundPlugin;

impl Plugin for PlaygroundPlugin {
    fn build(&self, app: &mut App) {
        app.add_system(setup.label(DeskSystem::UpdateWidget));
    }
}

fn setup(mut window: Query<(&mut Window<egui::Context>, &Workspace), With<DefaultWindow>>) {
    if let Ok((mut window, _kernel)) = window.get_single_mut() {
        window.add_widget(WidgetId::new(), PlaygroundWidget);
    }
}

pub struct PlaygroundWidget;

impl Widget<egui::Context> for PlaygroundWidget {
    fn render(&mut self, ctx: &mut Ctx<egui::Context>) {
        egui::Window::new("Editor").show(ctx.backend, |ui| {
            if ui.button("Fibonacci").clicked() {
                create_nodes_for_ast(ctx, &FIBONACCI);
            }
        });
    }
}

const FIBONACCI: Lazy<WithMeta<Expr>> = Lazy::new(|| {
    ast!(
        r#"
        ~~ type aliases
        'type add \ *<@"l" 'integer, @"r" 'integer> -> @"sum" 'integer;
        'type sub \ *<@"l" 'integer, @"r" 'integer> -> @"diff" 'integer;
        'type eq \ *<@"l" 'real, @"r" 'real> -> +<@"equal" *<>, @"unequal" *<>>;
        'type fib \ 'integer -> 'integer;

        ~~ let fib
        $ \ 'integer -> 'match ^eq *<@"l" &'integer, @"r" 0> '{
          ~~ if number == 0)
          @"equal" *<> => 0
          ~~ if number != 0
          @"unequal" *<> => 'match ^eq *<@"l" &'integer, @"r" 1> '{
            @"equal" *<> => 1
            @"unequal" *<> =>
              ~~ adds fib(number - 1) and fib(number - 2)
              <'integer> ^add *<
                @"l" ^fib ^sub *<@"l" &'integer, @"r" 1>
                @"r" ^fib ^sub *<@"l" &'integer, @"r" 2>
              >
          }'
        }';
        ^fib(7)
    "#
    )
});

fn create_nodes_for_ast(ctx: &mut Ctx<egui::Context>, expr: &WithMeta<Expr>) {
    struct Visitor<'a, 'b> {
        ctx: &'a mut Ctx<'b, egui::Context>,
    }
    // FIXME: implement using ExprVisitor generated by `#[derive(Visitor)]`
    impl Visitor<'_, '_> {
        fn add_event(&mut self, event: Event) {
            self.ctx.add_event(event);
        }
        #[must_use]
        fn visit_expr<'a>(&mut self, expr: &'a WithMeta<Expr>) -> &'a NodeId {
            let node_id = &expr.meta.id;
            match &expr.value {
                Expr::Literal(literal) => {
                    use deskc_ast::expr::Literal::*;
                    let content = match literal {
                        String(string) => Content::String(string.clone()),
                        Integer(int) => Content::Integer(*int),
                        Rational(a, b) => Content::Rational(*a, *b),
                        Real(real) => Content::Real(*real),
                    };
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content,
                    });
                }
                Expr::Do { stmt, expr } => {
                    let stmt = self.visit_expr(stmt);
                    let expr = self.visit_expr(expr);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Do,
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: stmt.clone(),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: expr.clone(),
                        },
                    });
                }
                Expr::Let { definition, body } => {
                    let definition = self.visit_expr(definition);
                    let body = self.visit_expr(body);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Let,
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: definition.clone(),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: body.clone(),
                        },
                    });
                }
                Expr::Perform { input, output } => {
                    let input = self.visit_expr(input);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Perform {
                            output: ast_type_to_type(output),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: input.clone(),
                        },
                    });
                }
                Expr::Continue { input, output } => {
                    let input = self.visit_expr(input);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Continue {
                            output: ast_type_to_type(output),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: input.clone(),
                        },
                    });
                }
                Expr::Handle { expr, handlers } => {
                    let expr = self.visit_expr(expr);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Handle,
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: expr.clone(),
                        },
                    });
                    for (index, handler) in handlers.iter().enumerate() {
                        let effect = &handler.value.effect;
                        let expr = self.visit_expr(&handler.value.handler);
                        self.add_event(Event::CreateNode {
                            node_id: handler.meta.id.clone(),
                            content: Content::Handler {
                                effect: Effect {
                                    input: ast_type_to_type(&effect.value.input),
                                    output: ast_type_to_type(&effect.value.output),
                                },
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: handler.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: expr.clone(),
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: handler.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Apply {
                    function,
                    link_name,
                    arguments,
                } => {
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Apply {
                            ty: ast_type_to_type(function),
                            link_name: link_name.clone(),
                        },
                    });
                    for (index, argument) in arguments.iter().enumerate() {
                        let argument = self.visit_expr(argument);
                        self.add_event(Event::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: argument.clone(),
                            },
                        });
                    }
                }
                Expr::Product(exprs) => {
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Product,
                    });
                    for (index, expr) in exprs.iter().enumerate() {
                        let expr = self.visit_expr(expr);
                        self.add_event(Event::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: expr.clone(),
                            },
                        });
                    }
                }
                Expr::Match { of, cases } => {
                    let of = self.visit_expr(of);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Match,
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: of.clone(),
                        },
                    });
                    for (index, case) in cases.iter().enumerate() {
                        let expr = self.visit_expr(&case.value.expr);
                        self.add_event(Event::CreateNode {
                            node_id: case.meta.id.clone(),
                            content: Content::Case {
                                ty: ast_type_to_type(&case.value.ty),
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: case.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: expr.clone(),
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: of.clone(),
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: case.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Typed { ty, item } => {
                    let item = self.visit_expr(item);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Typed {
                            ty: ast_type_to_type(ty),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::Hole => {
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Hole,
                    });
                }
                Expr::Function { parameter, body } => {
                    let body = self.visit_expr(body);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Function {
                            parameter: ast_type_to_type(parameter),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: body.clone(),
                        },
                    });
                }
                Expr::Vector(exprs) => {
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Vector,
                    });
                    for (index, expr) in exprs.iter().enumerate() {
                        let expr = self.visit_expr(expr);
                        self.add_event(Event::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: expr.clone(),
                            },
                        });
                    }
                }
                Expr::Map(elems) => {
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Map,
                    });
                    for (index, elem) in elems.iter().enumerate() {
                        let key = self.visit_expr(&elem.value.key);
                        let value = self.visit_expr(&elem.value.value);
                        self.add_event(Event::CreateNode {
                            node_id: elem.meta.id.clone(),
                            content: Content::MapElem,
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: elem.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: key.clone(),
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: elem.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 1,
                                node_id: value.clone(),
                            },
                        });
                        self.add_event(Event::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: elem.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Attributed { attr, item } => {
                    let node_id = self.visit_expr(item);
                    self.add_event(Event::PatchAttribute {
                        node_id: node_id.clone(),
                        patch: AttributePatch::Update {
                            key: attr.deduct_type(),
                            value: attr.clone(),
                        },
                    });
                    // Use the node_id of the item, not the attributed node.
                    return node_id;
                }
                Expr::DeclareBrand { brand, item } => {
                    let item = self.visit_expr(item);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::DeclareBrand {
                            brand: brand.clone(),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::Label { label, item } => {
                    let item = self.visit_expr(item);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Label {
                            label: label.clone(),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::NewType { ident, ty, expr } => {
                    let expr = self.visit_expr(expr);
                    self.add_event(Event::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::NewType {
                            ident: ident.clone(),
                            ty: ast_type_to_type(ty),
                        },
                    });
                    self.add_event(Event::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: expr.clone(),
                        },
                    });
                }
                Expr::Card { id, item, next } => todo!(),
            };
            node_id
        }
    }
    Visitor { ctx }.visit_expr(expr);
}
