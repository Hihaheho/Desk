use bevy::prelude::*;

use desk_plugin::DeskSystem;
use desk_window::{
    ctx::Ctx,
    widget::{Widget, WidgetId},
    window::{DefaultWindow, Window},
};
use deskc_ast::{
    expr::Expr,
    meta::WithMeta,
    ty::{Effect, EffectExpr, Type},
};
use deskc_ids::NodeId;
use deskc_macros::ast;
use deskc_type::DsonTypeDeduction;
use dworkspace::{
    prelude::{AttributePatch, Content, Event, EventPayload, OperandPatch},
    Workspace,
};

use once_cell::sync::Lazy;

pub struct PlaygroundPlugin;

impl Plugin for PlaygroundPlugin {
    fn build(&self, app: &mut App) {
        app.add_system(setup.label(DeskSystem::UpdateWidget));
    }
}

fn setup(mut window: Query<(&mut Window<egui::Context>, &Workspace), With<DefaultWindow>>) {
    if let Ok((mut window, _kernel)) = window.get_single_mut() {
        window.add_widget(WidgetId::new(), PlaygroundWidget);
    }
}

pub struct PlaygroundWidget;

impl Widget<egui::Context> for PlaygroundWidget {
    fn render(&mut self, ctx: &mut Ctx<egui::Context>) {
        egui::Window::new("Editor").show(&ctx.backend(), |ui| {
            if ui.button("Fibonacci").clicked() {
                create_nodes_for_ast(ctx, &FIBONACCI);
            }
        });
    }
}

const FIBONACCI: Lazy<WithMeta<Expr>> = Lazy::new(|| {
    ast!(
        r#"
        ~~ type aliases
        'type add \ *<@l 'integer, @r 'integer> -> @sum 'integer;
        'type sub \ *<@l 'integer, @r 'integer> -> @diff 'integer;
        'type eq \ *<@l 'real, @r 'real> -> +<@equal *<>, @unequal *<>>;
        'type fib \ 'integer -> 'integer;

        ~~ let fib
        $ \ 'integer -> 'match ^eq *<@l &'integer, @r 0> '{
          ~~ if number == 0)
          @equal *<> => 0
          ~~ if number != 0
          @unequal *<> => 'match ^eq *<@l &'integer, @r 1> '{
            @equal *<> => 1
            @unequal *<> =>
              ~~ adds fib(number - 1) and fib(number - 2)
              <'integer> ^add *<
                @l ^fib ^sub *<@l &'integer, @r 1>
                @r ^fib ^sub *<@l &'integer, @r 2>
              >
          }'
        }';
        ^fib(7)
    "#
    )
});

fn create_nodes_for_ast<'a>(ctx: &mut Ctx<egui::Context>, expr: &'a WithMeta<Expr>) -> &'a NodeId {
    struct Visitor<'a, 'b> {
        ctx: &'a mut Ctx<'b, egui::Context>,
    }
    // FIXME: implement using ExprVisitor generated by `#[derive(Visitor)]`
    impl Visitor<'_, '_> {
        fn add_event(&mut self, event: EventPayload) {
            self.ctx.add_event(event);
        }
        #[must_use]
        fn visit_expr<'a>(&mut self, expr: &'a WithMeta<Expr>) -> &'a NodeId {
            let node_id = &expr.meta.id;
            match &expr.value {
                Expr::Literal(literal) => {
                    use deskc_ast::expr::Literal::*;
                    let content = match literal {
                        String(string) => Content::String(string.clone()),
                        Integer(int) => Content::Integer(*int),
                        Rational(a, b) => Content::Rational(*a, *b),
                        Real(real) => Content::Real(*real),
                    };
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content,
                    });
                }
                Expr::Do { stmt, expr } => {
                    let stmt = self.visit_expr(stmt);
                    let expr = self.visit_expr(expr);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Do,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: stmt.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: expr.clone(),
                        },
                    });
                }
                Expr::Let { definition, body } => {
                    let definition = self.visit_expr(definition);
                    let body = self.visit_expr(body);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Let,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: definition.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: body.clone(),
                        },
                    });
                }
                Expr::Perform { input, output } => {
                    let input = self.visit_expr(input);
                    let output = self.visit_type(output);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Perform,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: input.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: output.clone(),
                        },
                    });
                }
                Expr::Continue { input, output } => {
                    let input = self.visit_expr(input);
                    let output = self.visit_type(output);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Continue,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: input.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: output.clone(),
                        },
                    });
                }
                Expr::Handle { expr, handlers } => {
                    let expr = self.visit_expr(expr);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Handle,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: expr.clone(),
                        },
                    });
                    for (index, handler) in handlers.iter().enumerate() {
                        let effect = self.visit_effect(&handler.value.effect);
                        let expr = self.visit_expr(&handler.value.handler);
                        self.add_event(EventPayload::CreateNode {
                            node_id: handler.meta.id.clone(),
                            content: Content::Handler,
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: handler.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: effect.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: handler.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 1,
                                node_id: expr.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: handler.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Apply {
                    function,
                    link_name,
                    arguments,
                } => {
                    let function = self.visit_type(function);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Apply {
                            link_name: link_name.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: function.clone(),
                        },
                    });
                    for (index, argument) in arguments.iter().enumerate() {
                        let argument = self.visit_expr(argument);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: argument.clone(),
                            },
                        });
                    }
                }
                Expr::Product(exprs) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Product,
                    });
                    for (index, expr) in exprs.iter().enumerate() {
                        let expr = self.visit_expr(expr);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: expr.clone(),
                            },
                        });
                    }
                }
                Expr::Match { of, cases } => {
                    let of = self.visit_expr(of);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Match,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: of.clone(),
                        },
                    });
                    for (index, case) in cases.iter().enumerate() {
                        let expr = self.visit_expr(&case.value.expr);
                        let ty = self.visit_type(&case.value.ty);
                        self.add_event(EventPayload::CreateNode {
                            node_id: case.meta.id.clone(),
                            content: Content::Case,
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: case.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: ty.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: case.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 1,
                                node_id: expr.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: *node_id,
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: case.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Typed { ty, item } => {
                    let ty = self.visit_type(ty);
                    let item = self.visit_expr(item);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Typed,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: ty.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::Hole => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Hole,
                    });
                }
                Expr::Function { parameter, body } => {
                    let body = self.visit_expr(body);
                    let parameter = self.visit_type(parameter);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Function,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: parameter.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: body.clone(),
                        },
                    });
                }
                Expr::Vector(exprs) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Vector,
                    });
                    for (index, expr) in exprs.iter().enumerate() {
                        let expr = self.visit_expr(expr);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: expr.clone(),
                            },
                        });
                    }
                }
                Expr::Map(elems) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Map,
                    });
                    for (index, elem) in elems.iter().enumerate() {
                        let key = self.visit_expr(&elem.value.key);
                        let value = self.visit_expr(&elem.value.value);
                        self.add_event(EventPayload::CreateNode {
                            node_id: elem.meta.id.clone(),
                            content: Content::MapElem,
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: elem.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 0,
                                node_id: key.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: elem.meta.id.clone(),
                            patch: OperandPatch::Insert {
                                index: 1,
                                node_id: value.clone(),
                            },
                        });
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: elem.meta.id.clone(),
                            },
                        });
                    }
                }
                Expr::Attributed { attr, item } => {
                    let node_id = self.visit_expr(item);
                    self.add_event(EventPayload::PatchAttribute {
                        node_id: node_id.clone(),
                        patch: AttributePatch::Update {
                            key: attr.deduct_type(),
                            value: attr.clone(),
                        },
                    });
                    // Use the node_id of the item, not the attributed node.
                    return node_id;
                }
                Expr::DeclareBrand { brand, item } => {
                    let item = self.visit_expr(item);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::DeclareBrand {
                            brand: brand.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::Label { label, item } => {
                    let item = self.visit_expr(item);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Label {
                            label: label.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Expr::NewType { ident, ty, expr } => {
                    let ty = self.visit_type(ty);
                    let expr = self.visit_expr(expr);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::NewType {
                            ident: ident.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: ty.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: expr.clone(),
                        },
                    });
                }
                Expr::Card { id, item, next } => {
                    let item = self.visit_expr(item);
                    self.add_event(EventPayload::PatchAttribute {
                        node_id: item.clone(),
                        patch: AttributePatch::Update {
                            key: todo!(),
                            value: todo!(),
                        },
                    });
                    let _ = self.visit_expr(next);
                    // Use the node_id of the next, not the card node.
                    return item;
                }
            };
            node_id
        }
        #[must_use]
        fn visit_type<'a>(&mut self, ty: &'a WithMeta<Type>) -> &'a NodeId {
            let node_id = &ty.meta.id;
            match &ty.value {
                Type::Labeled { brand, item } => {
                    let item = self.visit_type(item);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyLabeled {
                            brand: brand.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: item.clone(),
                        },
                    });
                }
                Type::Real => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyReal,
                    });
                }
                Type::Rational => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyRational,
                    });
                }
                Type::Integer => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyInteger,
                    });
                }
                Type::String => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyString,
                    });
                }
                Type::Effectful { ty, effects } => {
                    let ty = self.visit_type(ty);
                    let effects = self.visit_effect_expr(effects);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyEffectful,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: ty.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: effects.clone(),
                        },
                    });
                }
                Type::Infer => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Infer,
                    });
                }
                Type::Product(types) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyProduct,
                    });
                    for (index, ty) in types.iter().enumerate() {
                        let ty = self.visit_type(ty);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: ty.clone(),
                            },
                        });
                    }
                }
                Type::Sum(types) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Sum,
                    });
                    for (index, ty) in types.iter().enumerate() {
                        let ty = self.visit_type(ty);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: ty.clone(),
                            },
                        });
                    }
                }
                Type::Function(function) => {
                    let parameter = self.visit_type(&function.parameter);
                    let body = self.visit_type(&function.body);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyFunction,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: parameter.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: body.clone(),
                        },
                    });
                }
                Type::Vector(ty) => {
                    let ty = self.visit_type(ty);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyVector,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: ty.clone(),
                        },
                    });
                }
                Type::Map { key, value } => {
                    let key = self.visit_type(key);
                    let value = self.visit_type(value);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyMap,
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: key.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: value.clone(),
                        },
                    });
                }
                Type::Let {
                    variable,
                    definition,
                    body,
                } => {
                    let definition = self.visit_type(definition);
                    let body = self.visit_type(body);
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::TyLet {
                            ident: variable.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: definition.clone(),
                        },
                    });
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: body.clone(),
                        },
                    });
                }
                Type::Variable(ident) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Variable {
                            ident: ident.clone(),
                        },
                    });
                }
                Type::Attributed { attr, ty } => {
                    let node_id = self.visit_type(ty);
                    self.add_event(EventPayload::PatchAttribute {
                        node_id: node_id.clone(),
                        patch: AttributePatch::Update {
                            key: attr.deduct_type(),
                            value: attr.clone(),
                        },
                    });
                    // Use the node_id of the item, not the attributed node.
                    return node_id;
                }
                Type::Forall {
                    variable,
                    bound,
                    body,
                } => todo!(),
                Type::Exists {
                    variable,
                    bound,
                    body,
                } => todo!(),
            };
            node_id
        }
        fn visit_effect_expr<'a>(&mut self, effects: &'a WithMeta<EffectExpr>) -> &'a NodeId {
            let node_id = &effects.meta.id;
            match &effects.value {
                EffectExpr::Effects(effects) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::Effects,
                    });
                    for (index, effect) in effects.iter().enumerate() {
                        let effect = self.visit_effect(effect);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: effect.clone(),
                            },
                        });
                    }
                }
                EffectExpr::Add(exprs) => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::EAdd,
                    });
                    for (index, expr) in exprs.iter().enumerate() {
                        let expr = self.visit_effect_expr(expr);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index,
                                node_id: expr.clone(),
                            },
                        });
                    }
                }
                EffectExpr::Sub {
                    minuend,
                    subtrahend,
                } => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::ESub,
                    });
                    let minuend = self.visit_effect_expr(minuend);
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: minuend.clone(),
                        },
                    });
                    let subtrahend = self.visit_effect_expr(subtrahend);
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 1,
                            node_id: subtrahend.clone(),
                        },
                    });
                }
                EffectExpr::Apply {
                    function,
                    arguments,
                } => {
                    self.add_event(EventPayload::CreateNode {
                        node_id: node_id.clone(),
                        content: Content::EApply,
                    });
                    let function = self.visit_type(function);
                    self.add_event(EventPayload::PatchOperand {
                        node_id: node_id.clone(),
                        patch: OperandPatch::Insert {
                            index: 0,
                            node_id: function.clone(),
                        },
                    });
                    for (index, argument) in arguments.iter().enumerate() {
                        let argument = self.visit_type(argument);
                        self.add_event(EventPayload::PatchOperand {
                            node_id: node_id.clone(),
                            patch: OperandPatch::Insert {
                                index: index + 1,
                                node_id: argument.clone(),
                            },
                        });
                    }
                }
            };
            node_id
        }
        fn visit_effect<'a>(&mut self, effect: &'a WithMeta<Effect>) -> &'a NodeId {
            let node_id = &effect.meta.id;
            let input = self.visit_type(&effect.value.input);
            let output = self.visit_type(&effect.value.output);
            self.add_event(EventPayload::CreateNode {
                node_id: node_id.clone(),
                content: Content::Effect,
            });
            self.add_event(EventPayload::PatchOperand {
                node_id: node_id.clone(),
                patch: OperandPatch::Insert {
                    index: 0,
                    node_id: input.clone(),
                },
            });
            self.add_event(EventPayload::PatchOperand {
                node_id: node_id.clone(),
                patch: OperandPatch::Insert {
                    index: 1,
                    node_id: output.clone(),
                },
            });
            node_id
        }
    }
    Visitor { ctx }.visit_expr(expr)
}
