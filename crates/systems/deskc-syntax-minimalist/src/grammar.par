%start Expr
%title "Minimalist syntax for Desk-lang"
%comment ""

%scanner String {
    %auto_ws_off
    %auto_newline_off
}
%scanner BlockComment {
    %auto_ws_off
    %auto_newline_off
}
%scanner InlineComment {
    %auto_ws_off
}
%scanner Uuid {}
%scanner Ident {}

%%

Expr: Comment Expr
    | BeginKey^ Expr EndKey^
    | Hole
    | Do
    | Cast
    | Literal
    | Let
    | Perform
    | Continue
    | Handle
    | Product
    | Vector
    | Map
    | Attributed
    | Match
    | Function
    | Apply
    | Reference
    | Forall
    | Exists
    | Labeled
    | NewType
    | Card
    | Brand
    ;
    Do: DoKey^ Expr StmtEnd^ Expr;
    Cast: TypeBegin^ Ty TypeEnd^ Expr;
    Literal: Rational | Integer | Float | String;
        // Rational must be before Integer for higher priority.
        Rational: "\-?\p{Nd}+\s*/\s*\p{Nd}+";
        Integer: Hex | Oct | Bin | Dec;
            // Dec must be the last for lower priority.
            Hex: /0x[0-9a-fA-F]+/;
            Oct: /0o[0-7]+/;
            Bin: /0b[01]+/;
            Dec: /\-?\p{Nd}+/;
        Float: /\-?\p{Nd}+\.\p{Nd}+/;
        String: StringDelimiter^ %push(String) { Escaped | Characters | Newlines } StringDelimiter^ %pop();
            Escaped: <String> /\\[nt"\\]/;
            Characters: <String> /[^\\"]+/;
            Newlines: <String> /\\n+/;
    Let: LetSym^ Expr StmtEnd^ Expr;
    Perform: PerformSym^ Expr EArrow^ Ty;
    Continue: ContinueSym^ Expr EArrow^ Ty;
    Handle: HandleKey^ Expr BeginKey^ { Handler [ Comma^ ] } EndKey^;
        Handler: Ty EArrow^ Ty Arrow^ Expr;
    Product: ProductSym^ TypeBegin^ { Expr [ Comma^ ] } TypeEnd^;
    Vector: VecBegin^ { Expr [ Comma^ ] } VecEnd^;
    Map: MapBegin^ { Expr Arrow^ Expr [ Comma^ ] } MapEnd^;
    Attributed: Attribute Expr;
    Match: MatchKey^ Expr BeginKey^ { Case [ Comma^ ] } EndKey^;
        Case: Ty Arrow^ Expr;
    Function: FunctionSym^ Ty FArrow^ Expr;
    // We need `ApplySym` to make it deterministic on such a token: `*`.
    Apply: ApplySym^ [ LinkName ] Ty ( Param | Params );
        Param: Expr;
        Params: ParamsBegin^ { Expr [ Comma^ ] } ParamsEnd^;
    Reference: ReferenceSym^ [ LinkName ] Ty;
    Labeled: Label Expr;
    Forall: ForallKey^ BoundedVariable Expr;
    Exists: ExistsKey^ BoundedVariable Expr;
    NewType: TyKey^ Ident Ty StmtEnd^ Expr;
    Card: CardKey^ Uuid Expr StmtEnd^ Expr;
    Brand: BrandKey^ Expr StmtEnd^ Expr;

Ty: BeginKey^ Ty EndKey^
  | Infer
  | This
  | NumberKey
  | StringKey
  | Effectful
  | Comment Ty
  | Trait
  | ProductTy
  | Sum
  | VecTy
  | MapTy
  | FunctionTy
  | LabeledTy
  | AttributedTy
  | Variable
  | LetTy
  | ForallTy
  | ExistsTy
  ;
    Effectful: PerformSym^ EffectExpr Ty;
        EffectExpr: Effects | AddEffects | SubEffects| ApplyEffects;
        Effects: MapBegin^ { Effect [ Comma^ ] } MapEnd^;
        AddEffects: SumSym^ TypeBegin^ { EffectExpr [ Comma^ ] } TypeEnd^;
        SubEffects: Minus^ TypeBegin^ EffectExpr [ Comma^ ] EffectExpr TypeEnd^;
        ApplyEffects: ApplySym^ Ty ParamsBegin^ { Ty [ Comma^ ] } ParamsEnd^;
    Trait: TraitSym^ TypeBegin^ { FunctionTy [ Comma^ ] } TypeEnd^;
    ProductTy: ProductSym^ TypeBegin^ { Ty [ Comma^ ] } TypeEnd^;
    Sum: SumSym^ TypeBegin^ { Ty [ Comma^ ] } TypeEnd^;
    VecTy: VecBegin^ Ty VecEnd^;
    MapTy: MapBegin^ Ty Arrow^ Ty MapEnd^;
    FunctionTy: FunctionSym^ Ty FArrow^ Ty;
    LabeledTy: Label Ty;
    AttributedTy: Attribute Ty;
    Variable: Ident;
    LetTy: LetSym^ Ident Ty StmtEnd^ Ty;
    ForallTy: ForallKey^ BoundedVariable Ty;
    ExistsTy: ExistsKey^ BoundedVariable Ty;

// Utilities
Comment: BlockComment
       | InlineComment;
    // This must come before ParamsEnd for higher priority.
    BlockComment: CommentBegin^ %push(BlockComment) { BlockCommentContent } { ParamsEnd } CommentEnd ^ %pop();
    InlineComment: CommentPrefix^ %push(InlineComment) CommentCharacters %pop();
    CommentEnd: <BlockComment> ')~';
    BlockCommentContent: <BlockComment> /[^\)]+(\)[^~\)])?/;
    CommentCharacters: <InlineComment> /.*/;
Attribute: AttributeSym^ Expr;
Label: LabelSym^ Expr;
Ident: IdentRaw
     | IdentWrapped;
    IdentWrapped: IdentDelimiter^ %push(Ident) IdentPart { IdentPart } IdentDelimiter^ %pop();
    IdentRaw: /[^!-@\[-`\{-~\s]+/;
    IdentPart: <Ident> /([^`\s]|\\`)+/;
    IdentDelimiter: <INITIAL, Ident> '`';
Uuid: %push(Uuid) UuidText %pop();
    UuidText: <Uuid> /[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}/;
Effect: Ty EArrow^ Ty;
LinkName: CardKey^ Uuid | VersionKey^ Uuid;
// Tail comma is allowed, and this is important for writing readable code.
BoundedVariable: Ident [ TyAnno^ Ty ] [ Comma^ ];

// Composite tokens
// These must be listed first for higher priority.
Arrow: '=>';
FArrow: '->';
EArrow: '~>';
ContinueSym: '!<~';
CommentBegin: '~(';

// Tokens
// ".", "=" is not used.
CommentPrefix: '~';
Comma: ',';
StmtEnd: ';';
TyAnno: ':';
MapBegin: '{';
MapEnd: '}';
Hole: '?';
VecBegin: '[';
VecEnd: ']';
TypeBegin: '<';
TypeEnd: '>';
ParamsBegin: '(';
ParamsEnd: <INITIAL, BlockComment>')';
LabelSym: '@';
Infer: '_';
PerformSym: '!';
ReferenceSym: '&';
ApplySym: '^';
ProductSym: '*';
SumSym: '+';
Minus: '-';
LetSym: '$';
TraitSym: '%';
AttributeSym: '#';
// \u{5c} is '\'.
FunctionSym: /\u{5c}/;
StringDelimiter: <INITIAL, String>'"';

// Keywords
This: "'this";
DoKey: "'do";
TyKey: "'type";
ForallKey: "'forall";
ExistsKey: "'exists";
CardKey: "'card";
BrandKey: "'brand";
StringKey: "'string";
NumberKey: "'number";
HandleKey: "'handle";
MatchKey: "'match";
VersionKey: "'version";
BeginKey: "'begin";
EndKey: "'end";
