%start Expr
%title "Minimalist syntax for Desk-lang"
%comment ""

%scanner String {
    %auto_ws_off
    %auto_newline_off
}
%scanner BlockComment {
    %auto_ws_off
    %auto_newline_off
}
%scanner InlineComment {
    %auto_ws_off
}
%scanner Uuid {}
%scanner Ident {}

%%

Expr: Comment Expr
    | Hole
    | Do
    | Cast
    | Literal
    | Let
    | Perform
    | Continue
    | Handle
    | Product
    | Vector
    | Map
    | Attributed
    | Match
    | Function
    | Apply
    | Reference
    | Labeled
    | NewType
    | Card
    | Brand
    ;
    Do: DoKey^ Expr StmtEnd^ Expr;
    Cast: TyAnno^ Ty Expr;
    Literal: Rational | Integer | Float | String;
        // Rational must be before Integer for higher priority.
        Rational: "\-?\p{Nd}+\s*/\s*\p{Nd}+";
        Integer: Hex | Oct | Bin | Dec;
            // Dec must be the last for lower priority.
            Hex: /0x[0-9a-fA-F]+/;
            Oct: /0o[0-7]+/;
            Bin: /0b[01]+/;
            Dec: /\-?\p{Nd}+/;
        Float: /\-?\p{Nd}+\.\p{Nd}+/;
        String: StringDelimiter^ %push(String) { Escaped | Characters | Newlines } StringDelimiter^ %pop();
            Escaped: <String> /\\[nt"\\]/;
            Characters: <String> /[^\\"]+/;
            Newlines: <String> /\\n+/;
    Let: LetSym^ Expr StmtEnd^ Expr;
    Perform: PerformSym^ Expr EArrow^ Ty;
    Continue: ContinueSym^ Expr EArrow^ Ty;
    Handle: HandleKey^ Expr MapBegin^ { Handler [ Comma^ ] } MapEnd^;
        Handler: Ty EArrow^ Ty Arrow^ Expr;
    Product: ProductSym^ TypeBegin^ { Expr [ Comma^ ] } TypeEnd^;
    Vector: VecBegin^ { Expr [ Comma^ ] } VecEnd^;
    Map: MapBegin^ { Expr Arrow^ Expr [ Comma^ ] } MapEnd^;
    Attributed: Attribute Expr;
    Match: MatchKey^ Expr MapBegin^ { Case [ Comma^ ] } MapEnd^;
        Case: Ty Arrow^ Expr;
    Function: FunctionSym^ Ty FArrow^ Expr;
    Apply: ApplySym^ [ LinkName ] Ty ParamsBegin^ { Expr [ Comma^ ] } ParamsEnd^;
    Reference: ReferenceSym^ [ LinkName ] Ty;
    Labeled: Label Expr;
    NewType: TyKey^ Ident Ty StmtEnd^ Expr;
    Card: CardKey^ Uuid Expr StmtEnd^ Expr;
    Brand: BrandKey^ Expr StmtEnd^ Expr;

Ty: Infer
    | This
    | NumberKey
    | StringKey
    | Effectful
    | Comment Ty
    | Trait
    | ProductTy
    | Sum
    | VecTy
    | MapTy
    | FunctionTy
    | LabeledTy
    | AttributedTy
    | Variable
    | LetTy
    | All
    | Exist
    ;
    Effectful: PerformSym^ EffectExpr Ty;
        EffectExpr: Effects | AddEffects | SubEffects| ApplyEffects;
        Effects: MapBegin^ { Effect [ Comma^ ] } MapEnd^;
        AddEffects: SumSym^ TypeBegin^ { EffectExpr [ Comma^ ] } TypeEnd^;
        SubEffects: Minus^ TypeBegin^ EffectExpr [ Comma^ ] EffectExpr TypeEnd^;
        ApplyEffects: ApplySym^ Ty ParamsBegin^ { Ty [ Comma^ ] } ParamsEnd^;
    Trait: TraitSym^ TypeBegin^ { FunctionTy [ Comma^ ] } TypeEnd^;
    ProductTy: ProductSym^ TypeBegin^ { Ty [ Comma^ ] } TypeEnd^;
    Sum: SumSym^ TypeBegin^ { Ty [ Comma^ ] } TypeEnd^;
    VecTy: VecBegin^ Ty VecEnd^;
    MapTy: MapBegin^ Ty Arrow^ Ty MapEnd^;
    FunctionTy: FunctionSym^ Ty FArrow^ Ty;
    LabeledTy: Label Ty;
    AttributedTy: Attribute Ty;
    Variable: Ident;
    LetTy: LetSym^ Ident Ty StmtEnd^ Ty;
    All: AllKey^ Ident [ TyAnno^ Ty ] Ty;
    Exist: ExistKey^ Ident [ TyAnno^ Ty ] Ty;

// Utilities
Comment: CommentBegin^ %push(BlockComment) { BlockCommentContent } { ParenEnd } CommentEnd ^ %pop()
       | CommentPrefix^ %push(InlineComment) CommentCharacters %pop();
    // This must come before ParenEnd for higher priority.
    CommentEnd: <BlockComment> ')~';
    BlockCommentContent: <BlockComment> /[^\)]+(\)[^~\)])?/;
    ParenEnd: <BlockComment> ')';
    CommentCharacters: <InlineComment> /.*/;
Attribute: AttributeSym^ Expr;
Label: LabelSym^ Expr;
Ident: IdentRaw
     | IdentDelimiter^ %push(Ident) IdentPart { IdentPart } IdentDelimiter^ %pop();
    IdentRaw: /[^!-@\[-`\{-~\s]+/;
    IdentPart: <Ident> /([^`\s]|\\`)+/;
    IdentDelimiter: <INITIAL, Ident> '`';
Uuid: UuidKey^ %push(Uuid) UuidText %pop();
    UuidText: <Uuid> /[\p{Nd}a-fA-F]{8}-?[\p{Nd}a-fA-F]{4}-?[\p{Nd}a-fA-F]{4}-?[\p{Nd}a-fA-F]{4}-?[\p{Nd}a-fA-F]{4}-?[\p{Nd}a-fA-F]{12}/;
Effect: Ty EArrow^ Ty;
LinkName: CardKey Uuid | Uuid;

// Composite tokens
// These must be listed first for higher priority.
Arrow: '=>';
FArrow: '->';
EArrow: '~>';
ContinueSym: '<~';
CommentBegin: '~(';

// Tokens
// ".", "=" is not used.
CommentPrefix: '~';
Comma: ',';
StmtEnd: ';';
TyAnno: ':';
MapBegin: '{';
MapEnd: '}';
Hole: '?';
VecBegin: '[';
VecEnd: ']';
TypeBegin: '<';
TypeEnd: '>';
ParamsBegin: '(';
ParamsEnd: ')';
LabelSym: '@';
Infer: '_';
PerformSym: '!';
ReferenceSym: '&';
ApplySym: '^';
ProductSym: '*';
SumSym: '+';
Minus: '-';
LetSym: '$';
TraitSym: '%';
AttributeSym: '#';
// \u{5c} is '\'.
FunctionSym: /\u{5c}/;
StringDelimiter: <INITIAL, String>'"';

// Keywords
This: "'this";
DoKey: "'do";
TyKey: "'type";
UuidKey: "'uuid";
AllKey: "'forall";
ExistKey: "'exists";
CardKey: "'card";
BrandKey: "'brand";
StringKey: "'string";
NumberKey: "'number";
HandleKey: "'handle";
MatchKey: "'match";
